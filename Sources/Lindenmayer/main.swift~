import Foundation
struct ProductionRule {
    var predecessor: String
    var successor: String
}

struct LSystem {
    var alphabet: Set<Character>
    var axiom: Character 
    var productionRules: ProductionRules
}


let productionRules = [ProductionRule(predecessor:"1", successor:"11"),
                       ProductionRule(predecessor:"0", successor:"1[0]0")]
let lSystem = LSystem(alphabet:["0", "1", "[", "]"], axiom:"0", productionRules:productionRules)

//0&1
func nonTerminals() -> Set<Character> {
    var nonTerminals =  Set<Character>() 
    var pr = lSystem.productionRules 
    for character in lSystem.alphabet {
        for rule in pr {
            if rule.predecessor == character {
                nonTerminal.append(character)
            }
        }
    }
    return nonTerminals
}

//[&]
func terminals() -> Set<Character> {
}

func produce(generationCount:Int) -> String {

    if generationCount == 0 {
        return lSystem.axiom
    }else {
        terminalChars = terminals()
        nonTerminalChars = nonTerminals()
        result = produce(generationCount = 1)
        //sub result
        newResult = ""
        for character in result {
            if terminalChars.contains(character) {
                newResult.append(character)
            }else{
                newResult.append(getSub(character))
            }
        }
        return newResult
    }
}

func getSub(character:Character) -> String {
    for pr in productionRules {
        if pr.predecessor == character {
            return pr.sucessor
        }
    }
}
